// /data/questions.js

const questions = [
  {
    id: 1,
    title: "Two Sum",
    tags: ["array", "hashmap"],
    url: "https://leetcode.com/problems/two-sum/",
    description: "Given an array of integers and a target sum, find two numbers that add up to the target. Return their indices. Each input has one solution, and you cannot use the same element twice. Use a hashmap for efficient lookup.",
    difficulty: "Easy",
  },
  {
    id: 2,
    title: "Longest Substring Without Repeating Characters",
    tags: ["string", "sliding window"],
    url: "https://leetcode.com/problems/longest-substring-without-repeating-characters/",
    description: "Find the length of the longest substring in a given string without repeating characters. Use a sliding window to track unique characters, updating the window when duplicates are found to maximize the substring length efficiently.",
    difficulty: "Medium",
  },
  {
    id: 3,
    title: "Merge Intervals",
    tags: ["array", "sorting"],
    url: "https://leetcode.com/problems/merge-intervals/",
    description: "Given a list of intervals, merge all overlapping intervals into non-overlapping ones. Sort intervals by start time, then iterate to combine overlapping pairs, keeping track of start and end times for the merged intervals.",
    difficulty: "Medium",
  },
  {
    id: 4,
    title: "Longest Palindromic Substring",
    tags: ["string", "dynamic programming"],
    url: "https://leetcode.com/problems/longest-palindromic-substring/",
    description: "Find the longest substring in a string that is a palindrome, reading the same forwards and backwards. Use dynamic programming or expand around centers to check for palindromes, tracking the longest one found.",
    difficulty: "Medium",
  },
  {
    id: 5,
    title: "Coin Change",
    tags: ["dynamic programming"],
    url: "https://leetcode.com/problems/coin-change/",
    description: "Given coins of different denominations and a target amount, find the minimum number of coins needed to make the amount. Use dynamic programming to build solutions for smaller amounts up to the target.",
    difficulty: "Medium",
  },
  {
    id: 6,
    title: "Binary Tree Level Order Traversal",
    tags: ["tree", "bfs"],
    url: "https://leetcode.com/problems/binary-tree-level-order-traversal/",
    description: "Traverse a binary tree level by level, returning the node values in a list of lists. Use breadth-first search (BFS) with a queue to process each level, collecting nodes in order from top to bottom.",
    difficulty: "Medium",
  },
  {
    id: 7,
    title: "Climbing Stairs",
    tags: ["dp", "recursion"],
    url: "https://leetcode.com/problems/climbing-stairs/",
    description: "Find the number of distinct ways to climb n stairs, taking 1 or 2 steps at a time. Use dynamic programming or recursion to calculate the total combinations, similar to a Fibonacci sequence.",
    difficulty: "Easy",
  },
  {
    id: 8,
    title: "Detect Cycle in a Directed Graph",
    tags: ["graph", "dfs"],
    url: "https://www.geeksforgeeks.org/detect-cycle-in-a-directed-graph/",
    description: "Determine if a directed graph contains a cycle using depth-first search (DFS). Track visited nodes and nodes in the current recursion stack to identify back edges indicating a cycle in the graph.",
    difficulty: "Medium",
  },
  {
    id: 9,
    title: "Number of Islands",
    tags: ["dfs", "matrix"],
    url: "https://leetcode.com/problems/number-of-islands/",
    description: "Count the number of islands in a 2D grid, where an island is a group of connected 1s surrounded by 0s. Use DFS to explore and mark connected land cells, incrementing the island count for each group.",
    difficulty: "Medium",
  },
  {
    id: 10,
    title: "LRU Cache",
    tags: ["linked list", "hashmap"],
    url: "https://leetcode.com/problems/lru-cache/",
    description: "Implement a Least Recently Used (LRU) cache with get and put operations in O(1) time. Use a hashmap for key-value lookup and a doubly linked list to track the order of usage efficiently.",
    difficulty: "Medium",
  },
  {
    id: 11,
    title: "Valid Parentheses",
    tags: ["stack", "string"],
    url: "https://leetcode.com/problems/valid-parentheses/",
    description: "Check if a string of parentheses is valid, meaning all brackets are properly nested and closed. Use a stack to match opening and closing brackets, ensuring the stack is empty for valid strings.",
    difficulty: "Easy",
  },
  {
    id: 12,
    title: "Maximum Subarray",
    tags: ["array", "divide and conquer"],
    url: "https://leetcode.com/problems/maximum-subarray/",
    description: "Find the contiguous subarray with the largest sum in a given array. Use Kadane’s algorithm to track the maximum sum ending at each position, updating the global maximum as you iterate.",
    difficulty: "Medium",
  },
  {
    id: 13,
    title: "Symmetric Tree",
    tags: ["tree", "dfs"],
    url: "https://leetcode.com/problems/symmetric-tree/",
    description: "Check if a binary tree is symmetric, mirroring itself around its center. Use recursive DFS to compare left and right subtrees, ensuring corresponding nodes have equal values and mirrored structures.",
    difficulty: "Easy",
  },
  {
    id: 14,
    title: "Minimum Path Sum",
    tags: ["dp"],
    url: "https://leetcode.com/problems/minimum-path-sum/",
    description: "Find the minimum path sum from top-left to bottom-right in a grid, moving only down or right. Use dynamic programming to compute the minimum sum at each cell based on previous cells.",
    difficulty: "Medium",
  },
  {
    id: 15,
    title: "Word Break",
    tags: ["dp", "trie"],
    url: "https://leetcode.com/problems/word-break/",
    description: "Determine if a string can be segmented into words from a dictionary. Use dynamic programming to check if prefixes can be formed, or a trie for efficient word lookup in the dictionary.",
    difficulty: "Medium",
  },
  {
    id: 16,
    title: "Reverse Linked List",
    tags: ["linked list"],
    url: "https://leetcode.com/problems/reverse-linked-list/",
    description: "Reverse a singly linked list, changing the direction of all pointers. Iterate through the list, updating each node’s next pointer to point to the previous node, handling edge cases carefully.",
    difficulty: "Easy",
  },
  {
    id: 17,
    title: "Binary Search",
    tags: ["binary search"],
    url: "https://leetcode.com/problems/binary-search/",
    description: "Search for a target value in a sorted array using binary search. Repeatedly divide the search range in half, comparing the middle element to the target to find its index or determine it’s absent.",
    difficulty: "Easy",
  },
  {
    id: 18,
    title: "Find Peak Element",
    tags: ["array", "binary search"],
    url: "https://leetcode.com/problems/find-peak-element/",
    description: "Find a peak element in an array where it’s greater than its neighbors. Use binary search to compare midpoints, moving toward the side with a larger neighbor to ensure a peak is found.",
    difficulty: "Medium",
  },
  {
    id: 19,
    title: "Top K Frequent Elements",
    tags: ["heap", "hashmap"],
    url: "https://leetcode.com/problems/top-k-frequent-elements/",
    description: "Find the k most frequent elements in an array. Use a hashmap to count frequencies, then a min-heap or bucket sort to select the top k elements efficiently, handling ties appropriately.",
    difficulty: "Medium",
  },
  {
    id: 20,
    title: "Valid Anagram",
    tags: ["hashmap", "string"],
    url: "https://leetcode.com/problems/valid-anagram/",
    description: "Check if two strings are anagrams, containing the same characters with equal frequencies. Use a hashmap or array to count characters in one string and verify the other matches exactly.",
    difficulty: "Easy",
  },
  {
    id: 21,
    title: "Subsets",
    tags: ["backtracking"],
    url: "https://leetcode.com/problems/subsets/",
    description: "Generate all possible subsets of a given array of integers, including the empty set. Use backtracking to include or exclude each element, building all combinations recursively while avoiding duplicates.",
    difficulty: "Medium",
  },
  {
    id: 22,
    title: "Combination Sum",
    tags: ["backtracking"],
    url: "https://leetcode.com/problems/combination-sum/",
    description: "Find all unique combinations of numbers in an array that sum to a target value. Use backtracking to explore all possibilities, allowing reuse of numbers and collecting valid combinations.",
    difficulty: "Medium",
  },
  {
    id: 23,
    title: "Sort Colors",
    tags: ["array", "two pointers"],
    url: "https://leetcode.com/problems/sort-colors/",
    description: "Sort an array of 0s, 1s, and 2s in-place with a single pass. Use two pointers to partition the array, placing 0s at the start and 2s at the end efficiently.",
    difficulty: "Medium",
  },
  {
    id: 24,
    title: "Search in Rotated Sorted Array",
    tags: ["binary search"],
    url: "https://leetcode.com/problems/search-in-rotated-sorted-array/",
    description: "Search for a target value in a rotated sorted array using binary search. Determine which half is sorted, then decide which half to search based on the target’s range, handling edge cases.",
    difficulty: "Medium",
  },
  {
    id: 25,
    title: "Lowest Common Ancestor of a Binary Search Tree",
    tags: ["tree"],
    url: "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/",
    description: "Find the lowest common ancestor of two nodes in a binary search tree. Traverse the tree, moving left or right based on node values, stopping when paths to both nodes diverge.",
    difficulty: "Medium",
  },
  {
    id: 26,
    title: "Serialize and Deserialize Binary Tree",
    tags: ["tree", "dfs"],
    url: "https://leetcode.com/problems/serialize-and-deserialize-binary-tree/",
    description: "Serialize a binary tree to a string and deserialize it back to a tree. Use DFS to encode the tree structure and values, then reconstruct it by parsing the string recursively.",
    difficulty: "Hard",
  },
  {
    id: 27,
    title: "Word Search",
    tags: ["dfs", "backtracking"],
    url: "https://leetcode.com/problems/word-search/",
    description: "Find if a word exists in a 2D grid by traversing adjacent cells. Use DFS with backtracking to explore all paths, marking visited cells to avoid reuse and checking for matches.",
    difficulty: "Medium",
  },
  {
    id: 28,
    title: "House Robber",
    tags: ["dp"],
    url: "https://leetcode.com/problems/house-robber/",
    description: "Find the maximum amount you can rob from houses without robbing adjacent ones. Use dynamic programming to track the maximum money at each house, choosing to rob or skip each one.",
    difficulty: "Medium",
  },
  {
    id: 29,
    title: "Product of Array Except Self",
    tags: ["array"],
    url: "https://leetcode.com/problems/product-of-array-except-self/",
    description: "Compute the product of all numbers in an array except the current index without using division. Use two passes to calculate products of elements before and after each index efficiently.",
    difficulty: "Medium",
  },
  {
    id: 30,
    title: "Kth Largest Element in an Array",
    tags: ["heap"],
    url: "https://leetcode.com/problems/kth-largest-element-in-an-array/",
    description: "Find the kth largest element in an unsorted array. Use a min-heap to maintain the k largest elements or quickselect to partition the array, selecting the kth largest efficiently.",
    difficulty: "Medium",
  },
  {
    id: 31,
    title: "Maximum Product Subarray",
    tags: ["array", "dp"],
    url: "https://leetcode.com/problems/maximum-product-subarray/",
    description: "Find the contiguous subarray with the largest product in a given array. Track maximum and minimum products at each step using dynamic programming to handle negative numbers and zeros.",
    difficulty: "Medium",
  },
  {
    id: 32,
    title: "Binary Tree Zigzag Level Order Traversal",
    tags: ["tree", "bfs"],
    url: "https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/",
    description: "Traverse a binary tree level by level in a zigzag pattern, alternating left-to-right and right-to-left. Use BFS with a queue, reversing the order of nodes at each level as needed.",
    difficulty: "Medium",
  },
  {
    id: 33,
    title: "Generate Parentheses",
    tags: ["backtracking"],
    url: "https://leetcode.com/problems/generate-parentheses/",
    description: "Generate all valid combinations of n pairs of parentheses. Use backtracking to build strings, ensuring the number of open and close parentheses are balanced and valid at each step.",
    difficulty: "Medium",
  },
  {
    id: 34,
    title: "Implement Trie (Prefix Tree)",
    tags: ["trie"],
    url: "https://leetcode.com/problems/implement-trie-prefix-tree/",
    description: "Implement a trie data structure with insert, search, and prefix search operations. Store characters in a tree where each node represents a prefix, allowing efficient word and prefix lookups.",
    difficulty: "Medium",
  },
  {
    id: 35,
    title: "Number of Connected Components in an Undirected Graph",
    tags: ["graph", "dfs"],
    url: "https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/",
    description: "Count the number of connected components in an undirected graph. Use DFS or union-find to explore all nodes in each component, incrementing the count for each disconnected group found.",
    difficulty: "Medium",
  },
  {
    id: 36,
    title: "Find Minimum in Rotated Sorted Array",
    tags: ["binary search"],
    url: "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/",
    description: "Find the minimum element in a rotated sorted array using binary search. Compare the middle element with the ends to determine the sorted portion and locate the minimum efficiently.",
    difficulty: "Medium",
  },
  {
    id: 37,
    title: "Search a 2D Matrix",
    tags: ["binary search"],
    url: "https://leetcode.com/problems/search-a-2d-matrix/",
    description: "Search for a value in a sorted 2D matrix where rows and columns are sorted. Use binary search by treating the matrix as a flattened sorted array to find the target efficiently.",
    difficulty: "Medium",
  },
  {
    id: 38,
    title: "Merge k Sorted Lists",
    tags: ["linked list", "heap"],
    url: "https://leetcode.com/problems/merge-k-sorted-lists/",
    description: "Merge k sorted linked lists into one sorted linked list. Use a min-heap to select the smallest node from the lists, building the merged list incrementally with efficient comparisons.",
    difficulty: "Hard",
  },
  {
    id: 39,
    title: "Valid Sudoku",
    tags: ["matrix", "backtracking"],
    url: "https://leetcode.com/problems/valid-sudoku/",
    description: "Check if a 9x9 Sudoku board is valid by ensuring no duplicate digits in rows, columns, or 3x3 subgrids. Iterate through the board, using hashsets to track numbers in each section.",
    difficulty: "Medium",
  },
  {
    id: 40,
    title: "Course Schedule",
    tags: ["graph", "bfs"],
    url: "https://leetcode.com/problems/course-schedule/",
    description: "Determine if you can finish all courses given their prerequisites. Model as a directed graph and use DFS or BFS to detect cycles, indicating impossible course completion.",
    difficulty: "Medium",
  },
  {
    id: 41,
    title: "Kth Smallest Element in a BST",
    tags: ["tree", "dfs"],
    url: "https://leetcode.com/problems/kth-smallest-element-in-a-bst/",
    description: "Find the kth smallest element in a binary search tree. Use inorder DFS to traverse nodes in ascending order, tracking the kth visited node to return its value efficiently.",
    difficulty: "Medium",
  },
  {
    id: 42,
    title: "Minimum Window Substring",
    tags: ["string", "sliding window"],
    url: "https://leetcode.com/problems/minimum-window-substring/",
    description: "Find the smallest substring in a string containing all characters of another string. Use a sliding window with a hashmap to track character counts, minimizing the window size while satisfying requirements.",
    difficulty: "Hard",
  },
  {
    id: 43,
    title: "Longest Consecutive Sequence",
    tags: ["hashset"],
    url: "https://leetcode.com/problems/longest-consecutive-sequence/",
    description: "Find the length of the longest consecutive sequence in an unsorted array. Use a hashset to check for consecutive numbers, starting sequences only from the smallest number in each run.",
    difficulty: "Medium",
  },
  {
    id: 44,
    title: "Find All Anagrams in a String",
    tags: ["string", "sliding window"],
    url: "https://leetcode.com/problems/find-all-anagrams-in-a-string/",
    description: "Find all starting indices of anagrams of a pattern string in a given string. Use a sliding window with a hashmap to compare character frequencies, sliding efficiently to find matches.",
    difficulty: "Medium",
  },
  {
    id: 45,
    title: "Rotate Image",
    tags: ["matrix"],
    url: "https://leetcode.com/problems/rotate-image/",
    description: "Rotate a square matrix 90 degrees clockwise in-place. First transpose the matrix by swapping elements across the diagonal, then reverse each row to achieve the rotation efficiently.",
    difficulty: "Medium",
  },
  {
    id: 46,
    title: "Evaluate Reverse Polish Notation",
    tags: ["stack"],
    url: "https://leetcode.com/problems/evaluate-reverse-polish-notation/",
    description: "Evaluate an arithmetic expression given in Reverse Polish Notation. Use a stack to process operators and operands, popping numbers to compute results and pushing them back for further calculations.",
    difficulty: "Medium",
  },
  {
    id: 47,
    title: "Number of Islands II",
    tags: ["union find"],
    url: "https://leetcode.com/problems/number-of-islands-ii/",
    description: "Count the number of islands after adding land positions to a grid. Use union-find to merge adjacent land cells dynamically, tracking the number of distinct islands at each step.",
    difficulty: "Hard",
  },
  {
    id: 48,
    title: "Word Ladder",
    tags: ["graph", "bfs"],
    url: "https://leetcode.com/problems/word-ladder/",
    description: "Find the shortest transformation sequence from a start word to an end word, changing one letter at a time. Use BFS to explore all possible word transformations efficiently.",
    difficulty: "Hard",
  },
  {
    id: 49,
    title: "Alien Dictionary",
    tags: ["graph", "topological sort"],
    url: "https://leetcode.com/problems/alien-dictionary/",
    description: "Derive the order of characters in an alien language from a list of sorted words. Build a graph of character dependencies and use topological sort to determine the valid order.",
    difficulty: "Hard",
  },
  {
    id: 50,
    title: "Course Schedule II",
    tags: ["graph", "dfs"],
    url: "https://leetcode.com/problems/course-schedule-ii/",
    description: "Find a valid order to take courses given their prerequisites. Model as a directed graph, using DFS or topological sort to produce a valid course sequence or detect cycles.",
    difficulty: "Medium",
  },
  {
    id: 51,
    title: "Palindrome Partitioning",
    tags: ["backtracking"],
    url: "https://leetcode.com/problems/palindrome-partitioning/",
    description: "Partition a string into all possible combinations of palindrome substrings. Use backtracking to explore all cuts, checking each substring to ensure it’s a palindrome before adding to the result set.",
    difficulty: "Medium",
  },
  {
    id: 52,
    title: "Largest Rectangle in Histogram",
    tags: ["stack"],
    url: "https://leetcode.com/problems/largest-rectangle-in-histogram/",
    description: "Find the largest rectangular area in a histogram. Use a stack to track increasing bar heights, calculating areas when a smaller bar is encountered by popping bars and computing widths.",
    difficulty: "Hard",
  },
  {
    id: 53,
    title: "Sliding Window Maximum",
    tags: ["deque"],
    url: "https://leetcode.com/problems/sliding-window-maximum/",
    description: "Find the maximum element in each sliding window of size k in an array. Use a deque to maintain indices of potential maximums, removing outdated or smaller elements efficiently.",
    difficulty: "Hard",
  },
  {
    id: 54,
    title: "Count of Smaller Numbers After Self",
    tags: ["binary indexed tree"],
    url: "https://leetcode.com/problems/count-of-smaller-numbers-after-self/",
    description: "Count how many numbers are smaller than each element to its right in an array. Use a binary indexed tree or merge sort to track counts efficiently during processing.",
    difficulty: "Hard",
  },
  {
    id: 55,
    title: "Basic Calculator",
    tags: ["stack", "string"],
    url: "https://leetcode.com/problems/basic-calculator/",
    description: "Evaluate a string expression with basic arithmetic operations and parentheses. Use a stack to handle parentheses, processing signs and numbers to compute the final result while parsing the expression.",
    difficulty: "Hard",
  },
  {
    id: 56,
    title: "Implement Queue using Stacks",
    tags: ["stack", "queue"],
    url: "https://leetcode.com/problems/implement-queue-using-stacks/",
    description: "Implement a queue using two stacks with push, pop, peek, and empty operations. Use one stack for enqueue and another to reverse order for dequeue, ensuring FIFO behavior efficiently.",
    difficulty: "Medium",
  },
  {
    id: 57,
    title: "Binary Tree Maximum Path Sum",
    tags: ["tree", "dfs"],
    url: "https://leetcode.com/problems/binary-tree-maximum-path-sum/",
    description: "Find the maximum path sum in a binary tree, where the path can include any nodes. Use DFS to compute the maximum path through each node, updating a global maximum sum.",
    difficulty: "Hard",
  },
  {
    id: 58,
    title: "Count Primes",
    tags: ["math"],
    url: "https://leetcode.com/problems/count-primes/",
    description: "Count the number of prime numbers less than a given number n. Use the Sieve of Eratosthenes to mark non-prime numbers, then count the remaining primes efficiently.",
    difficulty: "Medium",
  },
  {
    id: 59,
    title: "Validate Binary Search Tree",
    tags: ["tree", "dfs"],
    url: "https://leetcode.com/problems/validate-binary-search-tree/",
    description: "Check if a binary tree is a valid binary search tree, ensuring all nodes satisfy BST properties. Use DFS with range checks to verify each node’s value lies within valid bounds.",
    difficulty: "Medium",
  },
  {
    id: 60,
    title: "Reverse Words in a String",
    tags: ["string"],
    url: "https://leetcode.com/problems/reverse-words-in-a-string/",
    description: "Reverse the order of words in a string while keeping words intact. Split the string, reverse the word array, and join back, handling multiple spaces and leading/trailing spaces appropriately.",
    difficulty: "Medium",
  },
  {
    id: 61,
    title: "Implement Stack using Queues",
    tags: ["stack", "queue"],
    url: "https://leetcode.com/problems/implement-stack-using-queues/",
    description: "Implement a stack using two queues with push, pop, top, and empty operations. Use queues to reverse the order of elements Eliminated: elements, ensuring LIFO behavior by rotating elements after each push.",
    difficulty: "Medium",
  },
  {
    id: 62,
    title: "Find the Duplicate Number",
    tags: ["array", "binary search"],
    url: "https://leetcode.com/problems/find-the-duplicate-number/",
    description: "Find the duplicate number in an array of n+1 integers from 1 to n. Use Floyd’s cycle detection or binary search to identify the repeated number without modifying the array.",
    difficulty: "Medium",
  },
  {
    id: 63,
    title: "Guess Number Higher or Lower",
    tags: ["binary search"],
    url: "https://leetcode.com/problems/guess-number-higher-or-lower/",
    description: "Guess a number between 1 and n using binary search. Use feedback from a guess function to determine if the guess is higher or lower, narrowing down to the correct number.",
    difficulty: "Easy",
  },
  {
    id: 64,
    title: "Split Array Largest Sum",
    tags: ["binary search", "dp"],
    url: "https://leetcode.com/problems/split-array-largest-sum/",
    description: "Split an array into m subarrays to minimize the largest subarray sum. Use binary search to find the minimum possible largest sum, checking feasibility with a greedy approach or DP.",
    difficulty: "Hard",
  },
  {
    id: 65,
    title: "Shortest Path in Binary Matrix",
    tags: ["bfs"],
    url: "https://leetcode.com/problems/shortest-path-in-binary-matrix/",
    description: "Find the shortest path from top-left to bottom-right in a binary matrix, moving in eight directions. Use BFS to explore all valid paths, returning the minimum distance or -1 if impossible.",
    difficulty: "Medium",
  },
  {
    id: 66,
    title: "Jump Game",
    tags: ["greedy"],
    url: "https://leetcode.com/problems/jump-game/",
    description: "Determine if you can reach the last index in an array by jumping based on given values. Use a greedy approach to track the furthest reachable index, checking if it reaches the end.",
    difficulty: "Medium",
  },
  {
    id: 67,
    title: "Insert Interval",
    tags: ["array"],
    url: "https://leetcode.com/problems/insert-interval/",
    description: "Insert a new interval into a list of non-overlapping intervals and merge if needed. Iterate through the list, adding non-overlapping intervals and merging overlapping ones to produce a sorted result.",
    difficulty: "Medium",
  },
  {
    id: 68,
    title: "Remove Nth Node From End of List",
    tags: ["linked list", "two pointers"],
    url: "https://leetcode.com/problems/remove-nth-node-from-end-of-list/",
    description: "Remove the nth node from the end of a linked list. Use two pointers with a gap of n nodes to locate and remove the target node in one pass.",
    difficulty: "Medium",
  },
  {
    id: 69,
    title: "Maximum Depth of Binary Tree",
    tags: ["tree", "dfs"],
    url: "https://leetcode.com/problems/maximum-depth-of-binary-tree/",
    description: "Find the maximum depth of a binary tree, defined as the longest path from root to leaf. Use DFS or BFS to traverse the tree, calculating the maximum depth recursively or level by level.",
    difficulty: "Easy",
  },
  {
    id: 70,
    title: "Serialize and Deserialize BST",
    tags: ["tree", "dfs"],
    url: "https://leetcode.com/problems/serialize-and-deserialize-bst/",
    description: "Serialize a binary search tree to a string and deserialize it back. Use preorder DFS to encode node values with separators, then reconstruct the BST using value ranges for insertion.",
    difficulty: "Medium",
  },
  {
    id: 71,
    title: "Flatten Binary Tree to Linked List",
    tags: ["tree"],
    url: "https://leetcode.com/problems/flatten-binary-tree-to-linked-list/",
    description: "Flatten a binary tree into a linked list in-place using preorder traversal. Rearrange pointers so each node’s right pointer links to the next node, effectively creating a single linked list.",
    difficulty: "Medium",
  },
  {
    id: 72,
    title: "Lowest Common Ancestor of a Binary Tree",
    tags: ["tree"],
    url: "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/",
    description: "Find the lowest common ancestor of two nodes in a binary tree. Use DFS to trace paths, returning the first node where paths to both nodes converge, handling all cases recursively.",
    difficulty: "Medium",
  },
  {
    id: 73,
    title: "Reverse Linked List II",
    tags: ["linked list"],
    url: "https://leetcode.com/problems/reverse-linked-list-ii/",
    description: "Reverse a portion of a linked list between two given positions. Locate the segment using pointers, reverse the nodes within it, and reconnect the reversed segment to the rest of the list.",
    difficulty: "Medium",
  },
  {
    id: 74,
    title: "Implement Magic Dictionary",
    tags: ["trie"],
    url: "https://leetcode.com/problems/implement-magic-dictionary/",
    description: "Implement a dictionary allowing searches for words with one character difference. Use a trie to store words, then search by trying all possible single-character replacements to find valid matches efficiently.",
    difficulty: "Medium",
  },
  {
    id: 75,
    title: "Find Median from Data Stream",
    tags: ["heap", "design"],
    url: "https://leetcode.com/problems/find-median-from-data-stream/",
    description: "Design a data structure to find the median of a stream of numbers. Use two heaps—a max-heap for the lower half and a min-heap for the upper half—to balance and compute the median.",
    difficulty: "Hard",
  },
  {
    id: 76,
    title: "Design Twitter",
    tags: ["design"],
    url: "https://leetcode.com/problems/design-twitter/",
    description: "Design a simplified Twitter system with post, follow, and news feed functionalities. Use hashmaps to store user relationships and posts, and a priority queue to fetch the 10 most recent tweets efficiently.",
    difficulty: "Medium",
  },
  {
    id: 77,
    title: "Trapping Rain Water",
    tags: ["stack", "two pointers"],
    url: "https://leetcode.com/problems/trapping-rain-water/",
    description: "Calculate the amount of water trapped between bars in a height map. Use two pointers or a stack to track boundaries, computing trapped water by finding the minimum of left and right maxima.",
    difficulty: "Hard",
  },
  {
    id: 78,
    title: "Find the Town Judge",
    tags: ["graph"],
    url: "https://leetcode.com/problems/find-the-town-judge/",
    description: "Identify the town judge in a directed graph based on trust relationships. The judge is trusted by all but trusts no one; use arrays to count trust relationships and verify the judge’s identity.",
    difficulty: "Easy",
  },
  {
    id: 79,
    title: "Design HashMap",
    tags: ["design"],
    url: "https://leetcode.com/problems/design-hashmap/",
    description: "Implement a hash map with put, get, and remove operations. Use an array of linked lists to handle collisions, hashing keys to indices and managing key-value pairs within each bucket efficiently.",
    difficulty: "Easy",
  },
  {
    id: 80,
    title: "Kth Smallest Element in a Sorted Matrix",
    tags: ["binary search", "heap"],
    url: "https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/",
    description: "Find the kth smallest element in a sorted n x n matrix. Use a min-heap to track potential next elements from each row or binary search to find the kth value efficiently.",
    difficulty: "Medium",
  },
  {
    id: 81,
    title: "Find Peak Element II",
    tags: ["matrix", "binary search"],
    url: "https://leetcode.com/problems/find-peak-element-ii/",
    description: "Find a peak element in a 2D matrix where it’s greater than its neighbors. Use binary search on columns to find a maximum, then check if it’s a peak, adjusting the search accordingly.",
    difficulty: "Medium",
  },
  {
    id: 82,
    title: "Maximal Rectangle",
    tags: ["stack", "matrix"],
    url: "https://leetcode.com/problems/maximal-rectangle/",
    description: "Find the largest rectangle containing only 1s in a binary matrix. Treat each row as a histogram, using a stack to compute the maximum rectangle area across all rows efficiently.",
    difficulty: "Hard",
  },
  {
    id: 83,
    title: "Number of Distinct Islands",
    tags: ["dfs", "graph"],
    url: "https://leetcode.com/problems/number-of-distinct-islands/",
    description: "Count the number of distinct island shapes in a 2D grid. Use DFS to capture each island’s shape as a unique path string, storing shapes in a set to count unique ones.",
    difficulty: "Medium",
  },
  {
    id: 84,
    title: "K Closest Points to Origin",
    tags: ["heap"],
    url: "https://leetcode.com/problems/k-closest-points-to-origin/",
    description: "Find the k points closest to the origin in a 2D plane. Use a max-heap to maintain the k closest points based on Euclidean distance, returning them in any order.",
    difficulty: "Medium",
  },
  {
    id: 85,
    title: "Minimum Number of Refueling Stops",
    tags: ["greedy", "heap"],
    url: "https://leetcode.com/problems/minimum-number-of-refueling-stops/",
    description: "Find the minimum number of refueling stops to reach a target distance. Use a greedy approach with a max-heap to select the largest fuel amounts from reachable stations, minimizing stops.",
    difficulty: "Hard",
  },
  {
    id: 86,
    title: "Number of Ways to Decode",
    tags: ["dp"],
    url: "https://leetcode.com/problems/decode-ways/",
    description: "Count the number of ways to decode a string of digits into letters (A=1, B=2, ..., Z=26). Use dynamic programming to compute valid decodings for each prefix of the string.",
    difficulty: "Medium",
  },
  {
    id: 87,
    title: "Shortest Distance from All Buildings",
    tags: ["bfs"],
    url: "https://leetcode.com/problems/shortest-distance-from-all-buildings/",
    description: "Find the shortest total distance from an empty land to all buildings in a grid. Use BFS from each building to compute distances, summing them to find the minimum total distance.",
    difficulty: "Hard",
  },
  {
    id: 88,
    title: "Expression Add Operators",
    tags: ["backtracking"],
    url: "https://leetcode.com/problems/expression-add-operators/",
    description: "Add operators (+, -, *) to a string of digits to reach a target value. Use backtracking to try all possible operator placements, evaluating expressions to find valid ones that equal the target.",
    difficulty: "Hard",
  },
  {
    id: 89,
    title: "Burst Balloons",
    tags: ["dp"],
    url: "https://leetcode.com/problems/burst-balloons/",
    description: "Maximize coins by bursting balloons in an array, multiplying adjacent values. Use dynamic programming to compute the maximum coins for each subarray, considering all possible last balloons to burst.",
    difficulty: "Hard",
  },
  {
    id: 90,
    title: "Longest Increasing Path in a Matrix",
    tags: ["dfs", "dp"],
    url: "https://leetcode.com/problems/longest-increasing-path-in-a-matrix/",
    description: "Find the longest increasing path in a matrix, moving to larger values in four directions. Use DFS with memoization to explore paths from each cell, caching lengths to avoid redundant computations.",
    difficulty: "Hard",
  },
  {
    id: 91,
    title: "Sliding Puzzle",
    tags: ["bfs"],
    url: "https://leetcode.com/problems/sliding-puzzle/",
    description: "Find the minimum moves to solve a 2x3 sliding puzzle to a target state. Use BFS to explore all possible board states, tracking moves to transform the puzzle to the desired configuration.",
    difficulty: "Hard",
  },
  {
    id: 92,
    title: "Find the Celebrity",
    tags: ["graph"],
    url: "https://leetcode.com/problems/find-the-celebrity/",
    description: "Identify a celebrity in a group where everyone knows them, but they know no one. Use a two-pass approach to find a candidate and verify they satisfy the celebrity conditions efficiently.",
    difficulty: "Medium",
  },
  {
    id: 93,
    title: "Design Circular Queue",
    tags: ["design"],
    url: "https://leetcode.com/problems/design-circular-queue/",
    description: "Implement a circular queue with enqueue, dequeue, front, rear, and isEmpty/isFull operations. Use an array with head and tail pointers, wrapping around to reuse space efficiently in a fixed-size queue.",
    difficulty: "Medium",
  },
  {
    id: 94,
    title: "Random Pick with Weight",
    tags: ["prefix sum", "binary search"],
    url: "https://leetcode.com/problems/random-pick-with-weight/",
    description: "Pick an index randomly based on given weights. Compute prefix sums of weights, then use binary search to select an index proportional to its weight, ensuring weighted random selection efficiently.",
    difficulty: "Medium",
  },
  {
    id: 95,
    title: "Max Area of Island",
    tags: ["dfs", "matrix"],
    url: "https://leetcode.com/problems/max-area-of-island/",
    description: "Find the maximum area of an island in a 2D grid, where an island is connected 1s. Use DFS to explore each island, counting connected cells to determine the largest island’s area.",
    difficulty: "Medium",
  },
  {
    id: 96,
    title: "Number of Closed Islands",
    tags: ["dfs", "matrix"],
    url: "https://leetcode.com/problems/number-of-closed-islands/",
    description: "Count the number of closed islands in a 2D grid, fully surrounded by water. Use DFS to explore islands, checking if they touch the grid’s boundary to exclude non-closed islands.",
    difficulty: "Medium",
  },
  {
    id: 97,
    title: "Design Snake Game",
    tags: ["design"],
    url: "https://leetcode.com/problems/design-snake-game/",
    description: "Design a snake game where the snake moves, eats food, and avoids collisions. Use a deque to track the snake’s body and a set for quick collision checks, updating positions per move.",
    difficulty: "Medium",
  },
  {
    id: 98,
    title: "Smallest Range Covering Elements from K Lists",
    tags: ["heap"],
    url: "https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists/",
    description: "Find the smallest range that includes one element from each of k sorted lists. Use a min-heap to track the smallest element from each list, minimizing the range while advancing pointers.",
    difficulty: "Hard",
  },
  {
    id: 99,
    title: "Longest Valid Parentheses",
    tags: ["stack", "dp"],
    url: "https://leetcode.com/problems/longest-valid-parentheses/",
    description: "Find the length of the longest valid parentheses substring in a string. Use a stack to track indices of unmatched parentheses or dynamic programming to compute the longest valid sequence efficiently.",
    difficulty: "Hard",
  },
  {
    id: 100,
    title: "Count Nodes Equal to Average of Subtree",
    tags: ["tree", "dfs"],
    url: "https://leetcode.com/problems/count-nodes-equal-to-average-of-subtree/",
    description: "Count nodes in a binary tree where the node’s value equals the average of its subtree. Use DFS to compute subtree sums and sizes, checking each node against its subtree’s average value.",
    difficulty: "Medium",
  },
];

export default questions;